#!/usr/bin/env python

from re import X
import rospy
from std_srvs.srv import Trigger, TriggerRequest
from sensor_msgs.msg import JointState, PointCloud2, LaserScan
from control_msgs.msg import FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectoryPoint

from scipy import optimize

import hello_helpers.hello_misc as hm
import math
import ros_numpy as rnp
import numpy as np

import laser_geometry.laser_geometry as lg
import matplotlib.pyplot as plt

lp = lg.LaserProjection()


class Robot(hm.HelloNode):

    def __init__(self):
        hm.HelloNode.__init__(self)

        self.rate = 10.0

        self.square_side = 3.5
        self.rotation_angle = -math.pi/2  # In radians
        self.mode = 'position'
        self.straight_command = {'joint': 'translate_mobile_base', 'inc': self.square_side}
        self.cw_command = {'joint': 'rotate_mobile_base', 'inc': -self.rotation_angle}
        self.ccw_command = {'joint': 'rotate_mobile_base', 'inc': self.rotation_angle}

        self.pc_baselink = None

        self.cluster_threshold = 0.02

        self.centroids = []

        #Publisher for the entire point cloud represented in base_link frame
        # self.baselink_pc_pub = rospy.Publisher("/pc_in_laser", PointCloud2, queue_size=1)

        #Publisher for the point cloud represented in base_link frame cropped to the relevant view window to the right of the robot
        # self.baselink_pc_pub_vw = rospy.Publisher("/laser_in_base", PointCloud2, queue_size=1)

    #def display_test_stats():

    def straight_motion(self, goal_point, trajectory_goal):

        joint_name = self.straight_command['joint']
        trajectory_goal.trajectory.joint_names = [joint_name]

        goal_point.positions = [self.straight_command['inc']]
        trajectory_goal.trajectory.points = [goal_point]
        trajectory_goal.trajectory.header.stamp = rospy.Time.now()
        self.trajectory_client.send_goal(trajectory_goal)

        self.trajectory_client.wait_for_result()

    
    def find_centres(self, xyz):

        cluster = np.asarray(xyz[:,0])
        cluster.reshape((-1,1))

        for i in range(1,xyz.shape[1]):            

            if np.linalg.norm([xyz[0,i] - xyz[0,i-1], xyz[1,i] - xyz[1,i-1]]) < self.cluster_threshold:
                cluster = np.hstack((cluster, xyz[:,i]))
            
            else:
                #Check if number of points in already collected cluster are > 3, if not continue 
                if len(cluster) < 3:
                    continue

                #If there are > 3 points, compute centroid and add to centroid collection
                elif len(cluster) < self.cluster_max_points:

                    #Best fit arc and corresponding cetroid
                    self.centriods.append(find_centroids(cluster))
                    
                #Restart cluster with current point
                cluster = np.asarray(xyz[:,i])
                cluster.reshape((-1,1))

        if self.centroids == []:
            print("No centroids found!")

    def main(self):
        hm.HelloNode.main(self,'navigation_scratch_pad', 'navigation', wait_for_first_pointcloud=False)

def find_centroids(cluster):

    x = cluster[0,:]
    y = cluster[1,:]

    x_m = np.average(x)
    y_m = np.average(y)

    center_estimate = x_m, y_m
    center_2, ier = optimize.leastsq(f_2, center_estimate, args=(cluster))

    xc_2, yc_2 = center_2
    Ri_2       = calc_R(*center_2, cluster)
    R_2        = Ri_2.mean()
    residu_2   = sum((Ri_2 - R_2)**2)

    return xc_2, yc_2


def calc_R(xc, yc, cluster):
    """ calculate the distance of each 2D points from the center (xc, yc) """
    x = cluster[0,:]
    y = cluster[1,:]
    return np.sqrt((x-xc)**2 + (y-yc)**2)


def f_2(c, cluster):
    """ calculate the algebraic distance between the data points and the mean circle centered at c=(xc, yc) """
    Ri = calc_R(*c, cluster)
    print(Ri - Ri.mean())
    return Ri - Ri.mean()


if __name__ == '__main__':

    try:
        node = Robot()
        node.main()

        lidar_subscriber = rospy.Subscriber('/scan', LaserScan, node.process_lidar)

        rospy.spin()

    except KeyboardInterrupt:
        rospy.loginfo('interrupt received bro!!! Gotcha!')
