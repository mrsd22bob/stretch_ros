#!/usr/bin/env python

import rospy
from std_srvs.srv import Trigger, TriggerRequest
from sensor_msgs.msg import JointState
from control_msgs.msg import FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectoryPoint
import yaml
from hello_helpers.simple_command_group import SimpleCommandGroup
from stretch_body.wrist_yaw import WristYaw
import numpy as np
import threading

import stretch_body.robot as rb
from stretch_body.hello_utils import ThreadServiceExit

from hello_helpers.simple_command_group import SimpleCommandGroup


import tf2_ros
import tf_conversions

import rospy
from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import Twist
from geometry_msgs.msg import TransformStamped

import actionlib
from control_msgs.msg import FollowJointTrajectoryAction
from control_msgs.msg import FollowJointTrajectoryResult

from std_srvs.srv import Trigger, TriggerResponse
from std_srvs.srv import SetBool, SetBoolResponse

from nav_msgs.msg import Odometry
from sensor_msgs.msg import JointState, Imu, MagneticField
from std_msgs.msg import Header

import hello_helpers.hello_misc as hm
import math
import time
import threading
import sys
import tf2_ros
import argparse as ap        
import numpy as np
import os

import hello_helpers.hello_misc as hm
import stretch_funmap.navigate as nv
import stretch_funmap.manipulation_planning as mp

import math

joint_range=3.4

class WristYawCommandGroup(SimpleCommandGroup):
    def __init__(self, range_rad=None, node=None):
        SimpleCommandGroup.__init__(self, 'joint_wrist_yaw', range_rad, node=node)

    def update_joint_range(self, joint_range, node=None):
        if joint_range is not None:
            self.range = joint_range
            return

        if node is None:
            return # cannot calculate range without Stretch Body handle
        range_ticks = node.robot.end_of_arm.motors['wrist_yaw'].params['range_t']
        range_rad = (node.robot.end_of_arm.motors['wrist_yaw'].ticks_to_world_rad(range_ticks[1]),
                     node.robot.end_of_arm.motors['wrist_yaw'].ticks_to_world_rad(range_ticks[0]))
        self.range = range_rad

    def init_execution(self, robot, robot_status, **kwargs):
        if self.active:
            robot.end_of_arm.move_by('wrist_yaw',
                                     self.update_execution(robot_status)[1],
                                     v_r=self.goal['velocity'],
                                     a_r=self.goal['acceleration'])

    def update_execution(self, robot_status, **kwargs):
        self.error = None
        if self.active:
            self.error = self.goal['position'] - robot_status['end_of_arm']['wrist_yaw']['pos']
            return self.name, self.error

        return None

    def joint_state(self, robot_status, **kwargs):
        yaw_status = robot_status['end_of_arm']['wrist_yaw']
        return (yaw_status['pos'], yaw_status['vel'], yaw_status['effort'])





class Manipulation_t1(hm.HelloNode, WristYawCommandGroup):

    def __init__(self):
        hm.HelloNode.__init__(self)

	self.rate = 7.0
	
	self.joint_range = 3.4

    def command_random(self):

	self.update_joint_range(self, self.joint_range, node=None)
	self.init_execution()
	self.update_execution()
	self.joint_state()



	#self.move_to_pose(self.random_p1)

	#self.trajectory_client.wait_for_result()

	#self.move_to_pose(self.random_p2)

	#self.trajectory_client.wait_for_result()
	
	

    def begin_test(self):

	rate = rospy.Rate(self.rate)
	self.command_random()

	

    def main(self):
	hm.HelloNode.main(self,'manipulation_test1', 'manipulation_test1', wait_for_first_pointcloud=False)

if __name__ == '__main__':

    try:
        node = Manipulation_t1()
	node.main()
	node.begin_test()
	rospy.spin()

    except KeyboardInterrupt:
        rospy.loginfo('interrupt received bro!!! Gotcha!')

